#!/usr/bin/ruby

# Dobry do testów jest obraz d3atiq/ubuntu-18.04-rdp-base
# Przykładowe wywołanie:
# vagrant --bridge="br0" --boxname="generic/alpine38" --vm-name="alpine-test" --cpus="2" --memory="512" --hostname="alpine-test" --gpu="0000:03:00.0,0000:03:00.1" up

# Jest kilka uwag do obraxzu vagrantowego:
# 1. Potrzebny jest qemu-ga na guescie
# 2. Potrzeba skonfigurowanego xrdp w srodku


require 'getoptlong'

# "args": ["--bridge=\"br0\"", "--boxname=\"generic/alpine38\"", "--vm-name=\"alpine-test\"","--cpus=\"2\"",
# "--memory=\"512\"", "--hostname=\"alpine-test\"", "--gpu=\"0000:03:00.0,0000:03:00.1\""],

class PCIAddress

  def initialize(string_addr)
    @original_address = string_addr

    first_split = string_addr.split(':', 3)
    @domain = first_split[0]
    @bus = first_split[1]
    second_split = first_split[2].split('.')
    @slot = second_split[0]
    @function = second_split[1]
  end

  def original_address
    return @original_address
  end

  def domain
    return "0x#{@domain}"
  end

  def bus
    return "0x#{@bus}"
  end

  def slot
    return "0x#{@slot}"
  end

  def function
    return "0x#{@function}"
  end

  def to_s
    return "domain:[#{domain}],bus:[#{bus}],slot:[#{slot}],function:[#{function}]"
  end
end

class GPUGroup

  def initialize(addresses_string)
    @addresses = Array.new()
    splitted = addresses_string.split(',')

    splitted.each do |addr|
      @addresses.push(PCIAddress.new(addr))
    end
  end

  def address_count
    return @addresses.length
  end

  def addresses
    @addresses
  end

  def to_s
    res = ''
    @addresses.each do |addr|
      res = res + addr.to_s + ';'
    end
    return res
  end
end

class Configuration 
    @@ENV_PREFIX = 'OCD_'
    
    def initialize
       @opts = GetoptLong.new(
         [ '--boxname',         GetoptLong::REQUIRED_ARGUMENT ],
         [ '--vm-name',         GetoptLong::REQUIRED_ARGUMENT ],
         [ '--cpus',            GetoptLong::REQUIRED_ARGUMENT ],
         [ '--memory',          GetoptLong::REQUIRED_ARGUMENT ],
         [ '--hostname',        GetoptLong::OPTIONAL_ARGUMENT ],
         [ '--bridge',          GetoptLong::REQUIRED_ARGUMENT ],
         [ '--gpu',             GetoptLong::OPTIONAL_ARGUMENT ],
       )
       set_default_values
    end
    
    def to_str
        puts "Variables passed to Vagrantfile"
        puts "boxname: #{@boxname}"
        puts "vm_name: #{@vm_name}"
        puts "cpus: #{@cpus}"
        puts "memory: #{@memory}"
        puts "bridge: #{@bridge}"
        puts "hostname: #{@hostname}"
        puts "gpu: #{@gpu.to_s}"
    end
    
    def parse_configuration
        parse_environment
        parse_arguments
    end
    
    def vm_name
        @vm_name
    end
    
    def hostname
        @hostname
    end
        
    def boxname
        @boxname
    end
            
    def cpus
        @cpus
    end
                
    def bridge
        @bridge
    end
    
    def memory
        @memory
    end
    
    def gpu
        @gpu.addresses
    end

    def gpu_attached
      return @gpu.address_count > 0
    end
    
    private
    
    def set_default_values
        @boxname        = 'pass_box_name_error' + (0...8).map { (65 + rand(26)).chr }.join
        @vm_name        = 'default'
        @cpus           = 1
        @memory         = 512
        @hostname       = @vm_name
        @bridge         = 'pass_bridge_device_name_error' + (0...8).map { (65 + rand(26)).chr }.join
        @gpu            = GPUGroup.new('')
    end
   
    def parse_environment
        @boxname        = ENV[@@ENV_PREFIX+'BOXNAME']
        @vm_name        = ENV[@@ENV_PREFIX+'VMNAME'] 
        @cpus           = ENV[@@ENV_PREFIX+'CPUS'] 
        @memory         = ENV[@@ENV_PREFIX+'MEMORY'] 
        @hostname       = ENV[@@ENV_PREFIX+'HOSTNAME']
        @bridge         = ENV[@@ENV_PREFIX+'BRIDGE'] 
        if ENV[@@ENV_PREFIX+'GPU']
          @gpu          = GPUGroup.new(ENV[@@ENV_PREFIX+'GPU']) 
        end
        
    end
   
    def parse_arguments
        begin
          @opts.each do |opt, arg|
            case opt
              when '--vm-name'
                @vm_name = arg
              when '--cpus'
                @cpus = arg
              when '--memory'
                @memory = arg
              when '--hostname'
                @hostname = arg
              when '--boxname'
                @boxname = arg
              when '--bridge'
                @bridge = arg
              when '--gpu'
                @gpu = GPUGroup.new(arg)
            end
          end
          rescue
        end
    end
end
conf = Configuration.new
conf.parse_configuration
puts conf.to_str

if conf.gpu_attached
  puts 'Attaching gpu'
  conf.gpu.each do |addr|
    puts "libvirt.pci :domain => #{addr.domain}, :bus => #{addr.bus}, :slot => #{addr.slot}, :function => #{addr.function}" 
  end
end

#Parametrized vagrant configuration with gpu
Vagrant.configure(2) do |config|
  config.ssh.password = "vagrant"
  config.nfs.functional = false
  config.vm.synced_folder '.', '/vagrant', disabled: true
  config.vm.define conf.vm_name
  config.vm.hostname = conf.hostname
  config.vm.network :public_network,
    :dev => conf.bridge,
    :mode => "bridge",
    :type => "bridge"
  config.vm.box = conf.boxname

  config.vm.provider :libvirt do |libvirt|
    libvirt.channel :type => 'unix', :target_name => 'org.qemu.guest_agent.0', :target_type => 'virtio'
    libvirt.qemu_use_agent = true
    libvirt.default_prefix = ""
    libvirt.title = conf.vm_name
    libvirt.host = "example.com"
    libvirt.memory = conf.memory
    libvirt.cpus = conf.cpus
    libvirt.uri = "qemu:///system" # deprecha - serwery wirtualizacji wcale nie sa potrzebne
    libvirt.kvm_hidden = true
    conf.gpu.each do |addr|
      libvirt.pci :domain => addr.domain, :bus => addr.bus, :slot => addr.slot, :function => addr.function 
    end
  end
end